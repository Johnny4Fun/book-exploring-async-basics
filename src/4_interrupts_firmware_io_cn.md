# 中断、固件与I/O

本书关于计算机科学主题的通识内容已经接近尾声了。

本部分要将所有的内容串起来，并研究整个计算机作为一个系统是如何处理I/O和并发的。

## 简要概述

让我们来看看从网卡中读取数据的步骤：

![Simplified Overview](./images/AsyncBasicsSimplified.png)

> **免责声明**
>
> 此处为简化内容，实际情况比这要复杂得多，但是我们只挑选我们最感兴趣的部分，跳过一些其他内容。

## 1. 代码部分

通过向操作系统发出一个`syscall`，我们申请到一个socket。根据操作系统的不同，我们要么拿到一个`文件描述符`（Linux/MacOS）或者`socket`结构体（Windows）。

下一步，告知操作系统，我希望在该socket有任何读事件发生时，操作系统能通知我。

## 2. 向操作系统注册事件

**处理方式有3种:**

A. 我们告诉操作系统我们对`Read`事件感兴趣，但我们希望通过将线程的控制权“交给”操作系统来等待该事件的发生。然后，操作系统通过存储寄存器状态来挂起我们的线程，并切换到其他的线程。

**从我们的视角（本程序的角度）来看，这个操作会阻塞住我们的线程，直到有数据可读。**

B. 我们告诉操作系统我们对`Read`事件感兴趣，但是我们只想拿到一个任务的句柄，通过`轮询（poll）`来检测数据是否已准备完毕。

**操作系统不会将我们的线程挂起，所以这种方式不会阻塞我们的程序**

C. 我们告诉操作系统我们可能对很多事件都感兴趣，但是我只想订阅一个事件队列。当我们`轮询`这个队列时，它会保持阻塞，直到有一个或多个事件发生。

**这种方式在我们等待事件发生时，会阻塞线程。**

> 我的下一本书将是关于方案C的，因为这是一个非常有趣的处理I/O事件的模型，这对于理解为什么Rusts的并发抽象模型会以那样的方式建模是非常重要的。我们在这里就不详细介绍了。

## 3. 网卡

> 在这部分，我们会跳过一些对于理解无关紧要的步骤。

网卡上有一个正运行着专用固件的微控制器。我们可以想象，这个微控制器在运行一个忙循环，不断地轮询，检测是否有数据输入。

> 网卡内部实际处理的方式很可能与上述内容有所差异。最重要的一点就是网卡上运行一块简单但专用的CPU，会不断地检测是否有事件到来。

网卡一旦感知到数据传入，就会发出硬件中断（Hardware Interrupt）。

## 4. 硬件中断

> 这是一个相当简化的解释。如果你对具体实现感兴趣，我推荐你去看看Robert Mustacchi's这篇给力的文章[Turtles on the wire: understanding how the OS uses the modern NIC](https://www.joyent.com/blog/virtualizing-nics)。

现代CPU有一系列的`中断请求线Interrupt Request Lines`（外围设备通过向IRQ产生信号来获得CPU的注意[英文解释](https://www.oreilly.com/library/view/pc-hardware-in/059600513X/ch01s03s01.html)）用于处理外围设备发出的事件。一个CPU的IRQ数量是固定的。

硬中断是一种随时可以发出的电信号。CPU会立即通过保存寄存器状态来`打断`当前正常的工作流，转而处理中断，查找对应的中断处理程序。中断处理函数定义在中断描述符表（Interrupt Descriptor Table）中。

## 5. 中断处理程序

操作系统在[中断描述符表（IDT，Interrupt Descriptor Table)](https://en.wikipedia.org/wiki/Interrupt_descriptor_table) 记录了可能会发生的不同中断所对应中断处理程序。其中的每一项都指向了特定中断对应的特定处理程序。网卡的中断处理程序通常是由其驱动注册和执行的。

> IDT并不像图中那样存储在CPU上。它位于主存中一个固定且已知的位置。CPU只在其中一个寄存器中持有指向表的指针。

## 6. 写入数据

取决于CPU和网卡固件，这一步可能会有很大的不同。如果网卡和CPU支持[直接支持访问（Direct Memory Access）](https://en.wikipedia.org/wiki/Direct_memory_access) （应该是所有现代操作系统的标配），网卡会直接将数据写入到操作系统在内存中已经创建好的一系列缓冲区中。

在这样的系统中，当有数据已经被写入内存时，网卡的`固件`可能才会发出一个`中断`信号。`DMA`的写入效率非常高，因为数据已经在内存中准备好后操作系统才会收到通知。而在相对较老的系统中，CPU处理网卡发来的数据是需要一定的资源开销的。

_支持DMA的系统需要添加DMAC（Direct Memory Access Controller）以控制内存的访问。DMAC并不是CPU的一部分，这点和上图有出入。我们已经讲得够深了，而且这点也不是很重要，所以我们继续下一部分。_

## 7. 驱动部分

通常来说，`驱动`负责处理操作系统和网卡之间的通信任务。

在某一时刻，缓冲区被填充完毕，网卡就会发出一个`中断`信号。接着，CPU会跳转到该中断对应的处理程序。这个特定类型的中断所对应的处理程序由驱动程序所注册的，所以实际上是驱动程序处理事件，再转而去通知内核：数据已经准备完毕，等待读取。

## 8. 读取数据

（此时数据已经准备完毕）取决于我们选择选项A、B还是C，操作系统会：

1. 唤醒（挂起的）线程
2. 在下次`轮询（poll）`时，返回`Ready`。
4. 唤醒线程，返回一个`Read`事件，也就是之前我们在socket句柄上注册监听的`Read`事件。

## 中断

正如我上面提到的，有两种类型的中断：

1. 硬中断
2. 软中断

二者在本质上有很大的区别

### 硬中断

CPU本身有两条中断请求线：非屏蔽中断和可屏蔽中断线。当这两条线上收到中断请求的电信号而引起的中断，则产生了硬中断。硬件线路直接通知CPU。

### 软中断

这类中断是通过软件而非硬件层面触发的。和硬件中断一样，CPU会跳转到中断描述符表，然后运行特定中断所对应的中断处理程序。


### 固件

大多数人不会关注固件。然而，固件其实是我们所生活的世界不可或缺的一部分。固件运行在各式各样的硬件上，有着各种稀奇古怪的工作方式，组成了我们每天接触的计算机。

每次一提到固件，我的脑海里总会浮现出星球大战里的场景：他们和各种奇怪、模糊的生物一同走进酒吧。我认为这就是固件的世界，而很少有人知道它们是做什么的或者在一个特定的系统上是如何工作的。

现如今，固件需要配合微控制器或者类似的设施以才能正常工作。即使是CPU，也需要固件的支持才能运作。这就意味着，一个硬件系统所承载的小型“CPU”比我们实际编程所面对的CPU的核心数量要多得多。

为什么这很重要？你还记得并发就是追求效率的，对吧？既然我们的系统上有这么多的CPU为我们干活，那么我们在编码时需要注意的一点就是不要重复那些CPU已经帮我们处理好的工作了。

如果网卡的固件能够持续不断地检测是否有新的数据到达，那么我们完全没有必要再让CPU浪费时间去执行同样的任务了。比较好的方式是每隔一段时间检测一次，更好的方式是在数据到达时通知CPU。
