# CPU需要与操作系统配合吗？

如果你在我第一次认为自己理解了程序的工作原理时问我这个问题，我很可能会回答“不”。因为当时的我认为：程序运行在CPU上，如果我们知道怎么样驱动CPU（比如写汇编），我们就能做到想做的事情。而如今，我知道了问题的答案是Yes。想要知道为何？那就听我来说说CPU和操作系统是如何协同工作的吧！

**当我看到类似下面的代码时，我就意识到我错了**

```rust
#![feature(llvm_asm)]
fn main() {
    let t = 100;
    let t_ptr: *const usize = &t;
    let x = dereference(t_ptr);

    println!("{}", x);
}

fn dereference(ptr: *const usize) -> usize {
    let res: usize;
    unsafe {
        llvm_asm!("mov ($1), $0":"=r"(res): "r"(ptr))
        };
    res
}
```

> 这里我们使用汇编指令，编写了一个名为`dereference`的函数。我们知道这里绝对没有操作系统的参与。

如你所见，这段代码会输出`100`，这正如我们所预料。但是，如果我们直接创建一个指向地址`99999999999999` 的无效指针，接着把这个指针传入同样的函数，看看会有什么效果。

```rust
#![feature(llvm_asm)]
fn main() {
    let t = 99999999999999 as *const usize;
    let x = dereference(t);

    println!("{}", x);
}
# fn dereference(ptr: *const usize) -> usize {
#     let res: usize;
#     unsafe {
#     llvm_asm!("mov ($1), $0":"=r"(res): "r"(ptr));
#     }
#
#     res
# }
```
结果是段错误（segmentation fault）。这结果并不出人意料，但是CPU怎么会知道我们不被允许访问这段内存。

- 是CPU每次访问某块内存时都会向操作系统询问：这个进程是否能够访问这段内存？
- 这样不会很慢吗？
- CPU是怎么知道在其之上有一个操作系统在运行呢？
- 所有CPU都明白段错误（segmentation fault）是什么意思吗？
- 为什么我们能够得到一条错误消息而不是单单进程崩溃掉呢？

## 打开通往新世界的大门

这是一个小小的未知领域。事实证明，操作系统和CPU之间有很多的合作，可能也并不是没有你想的那么简单。

很多现代的CPU都提供了一些供操作系统使用的基础架构。这些基础架构提供了我们所期望的安全性和稳定性。实际上，大多数高端CPU所提供的可选功能比Linux、BSD和Windows等操作系统实际用到的多得多。

这里我特别想说两点：

1. CPU如何阻止我们访问不该访问的内存地址？
2. CPU如何处理像I/O这样的异步事件？

_我们会在这章讨论第一个问题，把第二个问题放在下一章。_

> 如果你想了解更多关于这方面的细节，我一定要给你推荐 [Philipp Oppermann's excellent series](https://os.phil-opp.com/)。这本书写得相当好，不仅解答了上面的所有问题，还涵盖了更多其他内容。


## CPU如何阻止非法访问内存

我之前也提到了，现代的CPU已经定义了一些基本概念，比如：

- 虚拟内存（Virtual memory）
- 页表（Page table）
- 页错误（Page fault）
- 异常（Exceptions）
- 特权级别（[Privilege level](https://en.wikipedia.org/wiki/Protection_ring)）

不同CPU的具体实现不同，所以我们就笼统地讨论一下。

大多数的现代CPU都拥有一个内存管理单元（MMU，Memory Management Unit）。作为CPU的一部分，MMU的职责是将程序中使用的虚拟内存转换为实际的物理地址。

当操作系统启动了一个进程（比如我们的程序），它会为进程创建一个页表，并且确保CPU上的一个特定寄存器保存指向这个页表的指针。

当我们试图访问上面代码中的地址`t_ptr`，该地址会在某个时刻被送到MMU中进行转换，MMU会在页表中查询这个地址，将其转换为内存中的实际物理地址，再从该地址中拿到数据。

在第一个例子中，它会指向栈上的一个内存地址，所存储的值为`100`。

当我们传入的地址为`99999999999999` ，请求拿到该地址中储存的内容（这就是解引用操作）时，MMU会在页表中搜索其对应物理地址，但是找不到。

CPU就将此视为`页错误(page fault)`。

在启动引导阶段，操作系统会给CPU提供一张中断描述符表。这张表预定义了操作系统为CPU提供的一系列处理函数，用于处理可能会遇到的异常。

由于操作系统提供了一个函数指针来处理`段错误（Page Fault）`，所以当我们试图访问地址为`99999999999999` 时，CPU会跳转到该处理函数，从而将控制权转交给操作系统。

接着，操作系统就会打印一段友好的提示消息，通知我们发生了`段错误`。因为是操作系统输出的消息，所以这个消息可能因操作系统的不同而有所差异。

## 我们难道就不能直接把CPU里的页表（指针）改掉吗？

这时就轮到`特权级别（Privilege Level）`出场了。大多数的现代操作系统都用到了两层保护环/特权环——环0，即内核空间，与环3，用户空间。

![Privilege rings](./images/priv_rings.png)

大多数的CPU所拥有的环比操作系统所需要使用的要而更多。这其中有历史原因，这也是为什么使用`环0`和`环3`（而不是1、2）的原因。

页表中的每一项都有对应的（除了物理地址映射以外的）额外信息，其中一个是关于它归属于哪一级别环的信息。此项信息在操作系统启动时就已经设置好了。

执行在`环0`的代码几乎可以不受限制地访问外部设备、内存，还可以自由地修改在硬件级别提供安全保障的寄存器。

而你编写的、处于`环3`的代码对I/O和特定CPU寄存器（以及CPU指令）的访问往往相当受限。在`环3`下达指令或直接写寄存器以修改`页表（page table）`的行为会被CPU所阻止。CPU就会将此作为一个异常，然后跳转到操作系统提供的异常处理程序。

所以你别无选择，只能与操作系统配合，通过系统调用处理I/O任务。只有采取这样的方式，整个系统才能相对比较安全。