# I/O处理策略

在开始编写代码之前，我们将会探讨处理I/O和并发的不同策略。需要注意的是，我们现在是讨论一般性的I/O，但我还是会使用网络I/O来打比方。取决于I/O的类型，不同的策略可能具有不同的优势。

## 1. 使用操作系统提供的线程

完成I/O的一种方式是让操作系统来替我们处理一切。我们只需要为每个的任务创建一个线程，然后就像平时那样编写代码即可。

**优势**

- 易于理解
- 编码简单
- 性能良好
- 轻轻松松实现了并行

**劣势**

- 操作系统级别的线程分配的堆栈相当大。如果有同时有许多任务在等待处理（比如高负载下的Web服务），那么内存将很快被耗尽。
- 涉及到许多的系统调用。在大量任务的情况下，系统调用可能会产生相当大的开销。
- 操作系统需要处理很多任务（不仅仅是你的任务）。操作系统可能无法如你所期待的那样，快速地切换回你创建的线程。
- 操作系统不知道优先处理哪些任务，而你可能希望赋予某些任务更高的优先级以便其被优先处理。


## 2. 绿色线程（Green threads）

另一个处理I/O常见的方法是使用绿色线程。像Go这样的语言就利用这一点取得了巨大的成功。绿色线程在许多方面与操作系统提供的线程类似，但是其运行时能够进行调整以更好地适应特定需求。

**优势：**

- 用户使用方便。代码类似于使用操作系统级别的线程。
- 性能良好。
- 内存不足的可能性相对较小；相较于系统提供的线程，绿色线程内存占用要少。
- 用户对于线程如何调度有着绝对话语权，能够调整线程的优先级。

**劣势：**

- 你需要构建一个运行时环境，而这个运行时是在重复部分操作系统已经实现的功能。构建的运行时环境有时可能需要付出巨大的成本。
- 难以实现以灵活的方式来处理各式各样的任务。


## 3. 操作系统支持的、基于轮询的事件循环

我们今天讨论的第三种方案是最接近理想解的解决方案——我们告知操作系统，对特定事件的兴趣，接着，当事件完成时，让操作系统来通知我们。

这种方案的工作方式比如：我们告知操作系统，当有我们的数据到达网卡的时候，请通知我们。当某些情况发生时，网卡会发出一个中断信号，此时驱动程序会通知操作系统，数据已经准备完毕。

现在，我们还需要一种能够使任务在等待时能被“挂起”的方法，而这就是Node的”运行时“与Rust的Futures发挥作用的地方。

**优势：**

- 接近最优资源利用率
- 非常高效
- 为我们决定如何处理发生的事件提供了最大的灵活性

**劣势：**

- 不同的操作系统处理事件队列的方式不同，其中有些是和其他操作系统的方式截然不同的。一些操作系统对于这种方式支持的I/O类型有一定的限制。
- 较好的灵活性通常伴随着较高的复杂性
- 很难编写出一个合适的API，通过用一个抽象层去考虑不同操作系统之间的差异而不引入不必要的成本。
- 只解决了问题的一部分——程序员还是需要采取额外方案以挂起那些正在等待的任务。


## 最后的说明

Node的运行时既使用了方案1，也使用了方案3，但它要求所有的I/O都使用方案3。这样的设计也是Node能够很好地处理多连接并发的一部分原因。Node使用了基于回调函数的方式来挂起任务。

Rust的异步方案是基于方案3的。Rust社区花费了较长的一段时间来攻克方案3的缺点，以及额外确定一种挂起任务的方式。Rust的Futures包将任务建模为一个[状态机（State Machine）](https://en.wikipedia.org/wiki/Finite-state_machine)，挂起是其中的一种状态（挂起还有多种情况，不仅仅只有一种状态表示挂起）。

