# 项目规划

简要列举接下来我们需要完成的任务：

## 我们需要2个事件队列

1. 我们需要一个线程池来执行以下两种任务。
     - CPU密集型的任务
     - 操作系统提供的事件队列不支持的，而我们希望异步执行的任务（比如读取文件）。
2. 我们需要构建一个简单的跨平台`epoll/kqueue/IOCP`事件循环。这会很有意思，但是代码量也会很大。所以我们将这一节抽离出来，作为一本独立的“配套书籍”，给需要的人参考。这个库我们称之为`minimio`。

> 的确，我们打破了之前定下的规矩：不使用任何依赖。但这个是我们自己的库，而且到时候我们会详细地解释这个库。

## 我们需要一个运行时环境

**我们的运行时需要:**

1. 存储一系列需要在之后某些时间点运行的回调函数
3. 将任务投递到线程池中执行
6. 向操作系统注册我们所感兴趣的事件（通过`minimio`）
7. 向两个事件源/事件队列轮询（poll），从而获取新产生的事件
9. 处理定时器
11. 为像`Fs`和`Crypto`之类的”模块“提供一种注册任务的方式
13. 推动所有任务执行，直到全部结束

## 我们需要的几个模块

1. `Fs`用于处理文件系统
2. `Http`用于处理http请求
3. `Crypto`用于处理加解密相关的任务

## 我们需要编写一些helper

我们需要编写一些helper，使我们的代码可读性更强，以及展示我们所需要的一些输出信息。与实际的运行时相比，我们感兴趣的是何时发生了何事。为了达到这个需求，我们定义了三种额外的方式：

`print`会先打印该消息是从哪个线程中输出的，再打印传入的消息。

`print_content`与`print`的作用相同，是一种以友好的方式打印消息之外的内容的方法。

`current`能够方便地获取当前线程的名称。因为我们想要跟踪发生的一切，所以我们需要打印哪个线程输出了什么。这样就可以避免代码过于混乱。


## Minimio

Minimio是一个跨平台的基于epoll/kqueue/IOCP的事件循环，我们将在下一本书中介绍它。最初Minimio是本书的一部分，但是实现三种架构下的minimio比我们一开始想象得要复杂，需要更多的篇幅。

当epoll/kqueue/IOCP集中在一本单独的书里时，它也更容易阅读。

